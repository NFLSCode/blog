<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[COCI2009-2010#6]HOLMES 题解</title>
      <link href="/p/solution-p5191/"/>
      <url>/p/solution-p5191/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5191">题目传送门</a></p><p>定义：初始入度为 $0$ 的点为源点。</p><p>我们令 $S_i$ 为如果成立，就能够推出事件 $i$ 的源点集合。</p><p>则当事件 $i$ 成立时，显然 $S_i$ 中的点必有至少一个是真的。</p><p>所以我们只要把所有 $S_j$ 包含 $S_i$ 的事件 $j$ 都标记为真就行了。</p><p>bitset 实现，复杂度 $\Theta\left(\frac{D^3}{w}\right)$。</p><span id="more"></span><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;using namespace std;const int N&#123;1000&#125;;list&lt;int&gt; e[N+5];int ind[N+5];bitset&lt;N+5&gt; s[N+5];int d,m,n;void TP()&#123;    queue&lt;int&gt; q;    for (int i&#123;1&#125;;i&lt;=d;++i)        if (ind[i]==0) q.push(i),s[i][i]=1;    while (q.size())    &#123;        int u&#123;q.front()&#125;;q.pop();        for (auto v:e[u])        &#123;            --ind[v];            s[v]|=s[u];            if (ind[v]==0) q.push(v);        &#125;    &#125;&#125;int qp;int pp[MAXN];vector&lt;int&gt; ans;int main()&#123;    cin&gt;&gt;d&gt;&gt;m&gt;&gt;n;    for (int i&#123;1&#125;;i&lt;=m;++i)    &#123;        int a,b;        scanf(&quot;%d %d&quot;,&amp;a,&amp;b);        e[a].push_back(b);++ind[b];    &#125;    TP();    queue&lt;int&gt; q;    for (int i&#123;1&#125;;i&lt;=n;++i)        scanf(&quot;%d&quot;,&amp;qp),pp[qp]=true,q.push(qp);    while (q.size())    &#123;        int u&#123;q.front()&#125;;q.pop();        ans.push_back(u);        for (int j&#123;1&#125;;j&lt;=d;++j)        &#123;            if (pp[j]!=0) continue;            if ((s[j]&amp;s[u])==s[u])            &#123;                pp[j]=true;                q.push(j);            &#125;        &#125;        pp[u]=-1;    &#125;    sort(ans.begin(),ans.end());    for (auto x:ans) cout&lt;&lt;x&lt;&lt;&quot; &quot;;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>普通计算姬 题解</title>
      <link href="/p/solution-bzoj4765/"/>
      <url>/p/solution-bzoj4765/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hydro.ac/d/bzoj/p/4765/">题目传送门</a></p><p>序列分块。对于每一个块预处理出其答案。</p><p>考虑修改时对每一个块的贡献。因为每个点只对它祖先的答案有贡献，所以我们可以遍历整棵树，开一个桶记录当前每一个块的数个数。遍历到 x 时，将该桶的内容就是 x 对每个块的贡献，记录下来即可。这样修改时统计每个块 sum 加了多少就是贡献乘值的变化，$O(\sqrt{n})+\text{node modify}$。</p><p>查询时整块加起来，散块暴力求出每个点的子树和，$O(\sqrt{n})(1+\text{tree query})$。</p><p>显然我们需要一个数据结构维护 dfs 序上的单点加区间求和。</p><p>考虑根号平衡，分块维护前缀和数组，这样 $\text{node modify}$ 就相当于后缀加，$O(\sqrt{n})$，$\text{tree query}$ 就相当于单点查询，$\Theta(1)$。</p><p>如此，修改、查询复杂度为 $O(\sqrt{n})$，总复杂度 $O(n\sqrt{n})$。</p><p>显然不同块对答案的贡献可以独立计算，所以可以离线下来，每个块单独处理。这样空间 $\Theta(n\sqrt{n})\to\Theta(n)$（虽然 $\Theta(n\sqrt{n})$）也能通过）。</p><p><del>我这么懒的人肯定只会写在线</del></p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;using namespace std;// #define int uLLusing uLL=unsigned long long;inline int read() &#123;    char c;int x;    do x=(c=getchar())^48;    while (!isdigit(c));    while (isdigit(c=getchar()))    x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);    return x;&#125;const int N(1e5),B&#123;316&#125;,K&#123;N/B+1&#125;;int a[N+5];int n,gf[N+5][B+5],dfn[N+5],fz[N+5],dR[N+5];uLL val[N+5],tag[B+5],res[B+5];vector&lt;int&gt; e[N+5];inline int bl(int x)&#123;return x?(x-1)/K+1:0;&#125;inline int R(int b)&#123;return min(n,b*K);&#125;inline int L(int b)&#123;return R(b-1)+1;&#125;uLL query(int l,int r) &#123;    --l;    return val[r]+tag[bl(r)]-val[l]-tag[bl(l)];&#125;void modify(int p,int v) &#123;    for (int i&#123;p&#125;;i&lt;=R(bl(p));++i) val[i]+=v;    for (int i&#123;bl(p)+1&#125;;i&lt;=bl(n);++i) tag[i]+=v;&#125;uLL ppip(int l,int r) &#123;    uLL ans&#123;0&#125;;    for (int i&#123;l&#125;;i&lt;=r;++i) ans+=query(dfn[i],dR[i]-1);    return ans;&#125;void fz_init(int u,int fa) &#123;    static int cxx&#123;1&#125;,bf[B+5]&#123;&#125;;    fz[cxx]=u;dfn[u]=cxx++;    ++bf[bl(u)];    copy_n(bf+1,bl(n),gf[u]+1);    for (auto v:e[u])        if (v!=fa)            fz_init(v,u);    --bf[bl(u)];    dR[u]=cxx;&#125;int main() &#123;    // freopen(&quot;4765/1.in&quot;,&quot;r&quot;,stdin);    int n&#123;read()&#125;,m&#123;read()&#125;;::n=n;    for (int i&#123;1&#125;;i&lt;=n;++i)        a[i]=read();    for (int i&#123;1&#125;;i&lt;=n;++i) &#123;        int u&#123;read()&#125;,v&#123;read()&#125;;        e[u].push_back(v);        e[v].push_back(u);    &#125;    fz_init(e[0][0],0);    for (int i&#123;1&#125;;i&lt;=n;++i)        val[i]=val[i-1]+a[fz[i]];    for (int i&#123;1&#125;;i&lt;=n;++i)        res[bl(i)]+=query(dfn[i],dR[i]-1);    // for (int i&#123;1&#125;;i&lt;=bl(n);++i) cout&lt;&lt;gf[2000][i]&lt;&lt;endl;    while (m--) &#123;        int op&#123;read()&#125;,x&#123;read()&#125;,y&#123;read()&#125;;        if (op==1) &#123;            a[x]+=y-=a[x];            modify(dfn[x],y);            for (int i&#123;1&#125;;i&lt;=bl(n);++i)                res[i]+=(uLL)y*gf[x][i];        &#125; else &#123;            uLL ans;            if (bl(x)==bl(y)) &#123;                ans=ppip(x,y);            &#125; else &#123;                ans=ppip(x,R(bl(x)))+ppip(L(bl(y)),y);                for (int i&#123;bl(x)+1&#125;;i&lt;bl(y);++i)                    ans+=res[i];            &#125;            printf(&quot;%llu\n&quot;,ans);        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BZOJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Polyquine —— 同时在多种语言运行的自生成程式</title>
      <link href="/p/polyquine/"/>
      <url>/p/polyquine/</url>
      
        <content type="html"><![CDATA[<p>以下源代码遵循 CC BY-NC-ND 4.0 开源协议。</p><p>Quine AC记录（初版）：</p><p><a href="https://hydro.ac/d/zcoj/record/62cd7d02e4874952a0851613">C++14</a> <a href="https://hydro.ac/d/zcoj/record/62cd7d18e4874952a0851624">Python3</a></p><p>以后打算写一下原理。各版本原理不同，都打算写一下。</p><p>感谢 @<a href="https://www.luogu.com.cn/user/538464">GlaceonVGC</a> 的帮助，没有他该程序不可能实现。</p><span id="more"></span><p>当前版本：</p><p>ver 8（2warning，gnu++ only）</p><p>```python</p><h1 id="import"><a href="#import" class="headerlink" title="import/*"></a>import<cstdio>/*</h1><p>‘’’<em>/<br>main(){auto/</em>‘’’<br>def printf(a,<em>b):print(a%b,end=’’)#</em>/<br><em>=”#import<cstdio>/<em>%c’’’</em>/%cmain(){auto/<em>‘’’%cdef printf(a,</em>b):print(a%%b,end=’’)#*/%c</em>=%c%s%c;printf(<em>,10,10,10,10,34,</em>,34,10,10,10);%c#/*%c</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七彩树 题解</title>
      <link href="/p/solution-bzoj4771/"/>
      <url>/p/solution-bzoj4771/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hydro.ac/d/bzoj/p/4771/">题目传送门</a></p><p>让我们先解决几个问题。</p><h2 id="树链问题"><a href="#树链问题" class="headerlink" title="树链问题"></a>树链问题</h2><p>当树是一条链时，问题变为区间问题。</p><span id="more"></span><p>设结点的下标为其深度，对于每一个点，开一棵线段树维护这样的序列。</p><p>在父亲线段树的基础上，在当前结点下标上加一，同时在上一次出现该结点值的地方减一。</p><p>查询时在下标为 $dep_x+d$ 的那棵线段树上查询 $[x,n+1)$ 即可。</p><p>可以用主席树实现。</p><p>（SDOI2009 HH的项链）</p><p>我们发现，其实<strong>查询 $[l,r+1)$ 就够了</strong>。</p><h2 id="子树问题"><a href="#子树问题" class="headerlink" title="子树问题"></a>子树问题</h2><p>每次询问的深度都充分大时，问题变为询问一个子树的问题。</p><p>我们扩展上面的做法。观察发现一棵子树在 dfs 序上连续，从而把问题转化为 dfs 序上的区间问题。</p><h2 id="原问题"><a href="#原问题" class="headerlink" title="原问题"></a>原问题</h2><p>这样的询问无法像上面那样转化为区间问题了。</p><p>不过可以这么考虑：如果先更新深度小的线段树再更新大的，那岂不是说在一棵树上<strong>查询任何区间的答案都只统计到当前深度</strong>？</p><p>所以我们按 bfs 序去刷新线段树，但是线段树内仍维护 dfs 序，查询时查询<strong>待查集合内 dfs 序最靠后的结点就行了</strong>？</p><p>所以思路就是，线段树上维护 dfs 序，但是每个结点从 bfs 序的前一个更新而来，每次颜色相同的、dfs 序上和它距离最小的结点减一。查询的时候在子树内深度 $\leq dep_x+d$ 且在 dfs 序上最靠后的那棵线段树上查询以 $x$ 为根的子树这段 dfs 序即可。</p><p>不好意思，错了。</p><pre><code>6 11 2 3 3 4 51 2 1 4 44 2</code></pre><p>这时候是这样一棵树：</p><p><img src="https://hydro.ac/d/bzoj/file/2579/graph.png" alt="树的示意图"></p><p>每个结点上线段树的值：</p><pre><code>// bfs序1: 1000002: 1100004: 1101003: 1110005: 1110106: 111011</code></pre><p>查询的是结点 $6$ 上的 $[4,6+1)$（按照 dfs 序），答案为 $2$。</p><p>事实上，是 $3$ 号结点抹掉了 $4$ 号结点的值。</p><p>仔细想想，其实询问同时包含两个结点时，才需要减一。</p><p>而同时包含两个结点的，最深是它们的 LCA。所以在 LCA 上减一。</p><p>另外，容易发现，查询待查深度的最后一棵线段树即可。此时就算线段树有更改，也一定落在这棵子树的 dfs 序外面。这样每个深度维护一棵线段树即可。</p><p>就酱。</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;using namespace std;// limitsconst int VL&#123;1&#125;,VR(1e5),N(1e5),L&#123;20&#125;;// persistent segstruct tnode;vector&lt;tnode&gt; mem;struct pnode&#123;    int id;    tnode&amp; operator*()&#123;return mem[id];&#125;    tnode* operator-&gt;()&#123;return &amp;mem[id];&#125;    pnode&amp; operator=(pnode n)&#123;id=n.id;return *this;&#125;    pnode(int p=0):id&#123;p&#125;&#123;&#125;&#125;;struct tnode&#123;    pnode l,r;    int sz;&#125;;pnode new_tnode()&#123;mem.emplace_back();return mem.size()-1;&#125;pnode Insert(pnode,int,int,int);int query(pnode,int,int,int,int);// treevector&lt;int&gt; e[N+5];int dfp[N+5];pnode tree[N+5];// nodeint cl[N+5],fa[N+5][L+5];int dep[N+5],dfn[N+5],sz[N+5],cxx;int LCA(int,int);// preparationpnode init();// colorset&lt;int&gt; col[N+5];int close(int);int main()&#123;    int T;cin&gt;&gt;T;    while (T--)    &#123;        int n,m;cin&gt;&gt;n&gt;&gt;m;        for (int i&#123;1&#125;;i&lt;=n;++i)            scanf(&quot;%d&quot;,cl+i);        for (int i&#123;1&#125;;i&lt;=n;++i)            e[i].clear(),col[cl[i]].clear();        for (int i&#123;2&#125;;i&lt;=n;++i)        &#123;            int p;scanf(&quot;%d&quot;,&amp;p);            e[p].push_back(i);            fa[i][0]=p;        &#125;        tree[0]=init();        vector&lt;int&gt; bfn;        for (int i&#123;1&#125;;i&lt;=n;++i)            bfn.push_back(i);        sort(bfn.begin(),bfn.end(),[](int a,int b)&#123;return dep[a]&lt;dep[b]||dep[a]==dep[b]&amp;&amp;dfn[a]&lt;dfn[b];&#125;);        int ct&#123;0&#125;;        for (auto u:bfn)        &#123;            tree[dep[u]]=Insert(tree[ct],dfn[u],1,n);            ct=dep[u];            if (col[cl[u]].size()) tree[ct]=Insert(tree[ct],dfn[close(u)],-1,n);            col[cl[u]].insert(dfn[u]);        &#125;        // cout&lt;&lt;&quot;qwq&quot;&lt;&lt;mem[3].r.id&lt;&lt;endl;        int last&#123;0&#125;;        while (m--)        &#123;            int x,d;scanf(&quot;%d %d&quot;,&amp;x,&amp;d);            x^=last;d^=last;            printf(&quot;%d\n&quot;,last=query(tree[dep[x]+d],dfn[x],sz[x]+1,1,n+1));        &#125;    &#125;    return 0;&#125;// binary despint jmp(int x,int d)&#123;    for (int i&#123;0&#125;;d;++i)    &#123;        if (d&amp;1) x=fa[x][i];        d&gt;&gt;=1;    &#125;    return x;&#125;int LCA(int a,int b)&#123;    if (dep[a]&lt;dep[b]) swap(a,b);    a=jmp(a,dep[a]-dep[b]);    if (a==b) return a;    for (int i&#123;L&#125;;i&gt;=0;--i)        if (fa[a][i]!=fa[b][i])            a=fa[a][i],b=fa[b][i];    return fa[a][0];&#125;void fz_init(int u)&#123;    dfn[u]=++cxx;dfp[cxx]=u;    dep[u]=dep[fa[u][0]]+1;    for (int i&#123;1&#125;;i&lt;=L;++i)        fa[u][i]=fa[fa[u][i-1]][i-1];    for (auto v:e[u])        fz_init(v);    sz[u]=cxx;&#125;pnode init()&#123;    cxx=0;    fz_init(1);    mem.clear();mem.emplace_back();    return 0;&#125;pnode Insert(pnode p,int k,int v,int cnt)&#123;    pnode q&#123;new_tnode()&#125;;    *q=*p;    // printf(&quot;%d: p%d,q%d\n&quot;,k,p.id,q.id);    q-&gt;sz+=v;    if (cnt==1) return q;    int cp&#123;cnt&gt;&gt;1&#125;;    if (k&lt;=cp) q-&gt;l=Insert(p-&gt;l,k,v,cp);    else q-&gt;r=Insert(p-&gt;r,k-cp,v,cnt-cp);    // cout&lt;&lt;&amp;(q-&gt;l)&lt;&lt;&quot; &quot;&lt;&lt;&amp;(mem[q.id].l)&lt;&lt;endl;;    // cout&lt;&lt;q-&gt;l.id&lt;&lt;endl;    // printf(&quot;fin %d: q%d %d\n&quot;,k,q-&gt;l,q-&gt;r);    return q;&#125;int query(pnode p,int L,int R,int pL,int pR)&#123;    if (p.id==0) return 0;    if (L&lt;=pL&amp;&amp;pR&lt;=R) return p-&gt;sz;    int mid&#123;pL+pR&gt;&gt;1&#125;,ans&#123;0&#125;;    if (L&lt;mid) ans+=query(p-&gt;l,L,R,pL,mid);    if (R&gt;mid) ans+=query(p-&gt;r,L,R,mid,pR);    return ans;&#125;int close(int p)&#123;    auto&amp; s&#123;col[cl[p]]&#125;;    auto il&#123;s.lower_bound(dfn[p])&#125;,iu&#123;s.upper_bound(dfn[p])&#125;;    if (il!=s.begin())        if (iu!=s.end())        &#123;            int l&#123;LCA(dfp[*prev(il)],p)&#125;,u&#123;LCA(dfp[*iu],p)&#125;;            if (dep[l]&gt;dep[u]) return l;            else return u;        &#125;        else return LCA(dfp[*prev(il)],p);    else return LCA(dfp[*iu],p);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BZOJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[POI2015]ODW 题解</title>
      <link href="/p/solution-p3591/"/>
      <url>/p/solution-p3591/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3591">题目传送门</a></p><p>这是一个树剖+序列分块。感觉因为单纯树剖跑不满 log，比树上k级祖先+根号分治的做法要快一些。</p><span id="more"></span><p>对于查询的两个端点，记余数 $m_u,m_v$ 为 $1$。</p><p>每次树剖跳 $u$ 的时候，在序列上查询这一段模数为 $k$，且下标（从1开始）余数为 $m_u$ 的和，再令 $m_u=(m_u-l)\mod k$（$l$ 是查询区间的长度）。跳 $v$ 同理。</p><p>对 dfs 序进行分块，块大小为 $S$。每块对于 $1\leq k\leq S$ 的模数预处理出下标（从1开始）余数为 $0\leq m&lt;k$ 的和。</p><p>散块暴力跳，跑完每个块，余数类似树剖那段进行变化。</p><p>如果查询的 $k\geq S$，就直接暴力跳整个区间。</p><p>一个小问题是树剖是倒着跳的，在正的 dfs 序上查询余数有点麻烦。</p><p>所以我们把每个点在 dfs 序上的位置变为 <code>n-dfn[x]+1</code>，相当于分块维护反 dfs 序。</p><p>本质类似根号分治做法，但充分利用了树剖的特性而不是每次就只跳 $S$。</p><p>取 $S=\sqrt{n}$，时间 $O(n\lg n\sqrt{n})$，空间 $\Theta(n\sqrt{n})$。</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;using namespace std;inline int read()&#123;    char c;int x,f&#123;0&#125;;    do x=(c=getchar())^48;    while (!isdigit(c)&amp;&amp;c!=&#39;-&#39;);    if (x==29) f=-1,x=0;    while (isdigit(c=getchar()))        x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);    return (x^f)-f;&#125;const int N(5e4),B&#123;223*20&#125;,K&#123;N/B+1&#125;;// val是dfs序上的点权int sum[B+5][K][K],val[N+5],a[N+5],n;inline int R(int b)&#123;return b*K;&#125;inline int L(int b)&#123;return R(b-1)+1;&#125;inline int bl(int x)&#123;return (x-1)/K+1;&#125;;int ppip(int l,int r,int k,int m)&#123;    if (!m) m=k;    int ans&#123;0&#125;;    for (int i&#123;l+m-1&#125;;i&lt;=r;i+=k)        ans+=val[i];    return ans;&#125;// 序列分块int query(int l,int r,int k,int m)&#123;    if (bl(l)==bl(r)) return ppip(l,r,k,m);    int ans&#123;ppip(l,R(bl(l)),k,m)&#125;;    m=(m+k-(R(bl(l))-l+1)%k)%k;    assert(R(bl(r)-1)&lt;=n);    for (int i&#123;bl(l)+1&#125;;i&lt;bl(r);++i) &#123;        if (k&gt;=K) &#123;            if (k==K&amp;&amp;m==0) ans+=val[R(i)];            else if (m&lt;=K&amp;&amp;m) ans+=val[L(i)+m-1];        &#125; else ans+=sum[i][k][m];        m=(m+k-K%k)%k;    &#125;    ans+=ppip(L(bl(r)),r,k,m);    return ans;&#125;int fa[N+5],dep[N+5],sz[N+5],son[N+5],tp[N+5];int dfn[N+5];vector&lt;int&gt; e[N+5];// 树剖void fz_init(int u,int f)&#123;    fa[u]=f;dep[u]=dep[f]+1;sz[u]=1;    for (auto v:e[u])        if (v!=f) &#123;            fz_init(v,u);            sz[u]+=sz[v];            if (sz[v]&gt;sz[son[u]])                son[u]=v;        &#125;&#125;void fz_cut(int u,int top)&#123;    static int cxx&#123;1&#125;;    tp[u]=top;dfn[u]=cxx++;    if (son[u]) fz_cut(son[u],top);    for (auto v:e[u])        if (v!=fa[u]&amp;&amp;v!=son[u])            fz_cut(v,v);&#125;int query(int u,int v,int k)&#123;    int wu&#123;1%k&#125;,wv&#123;1%k&#125;,ans&#123;0&#125;;    while (tp[u]!=tp[v])&#123;        if (dep[tp[u]]&lt;dep[tp[v]])            swap(u,v),swap(wu,wv);        // 注意反dfs序反着询问        ans+=query(dfn[u],dfn[tp[u]],k,wu);        wu=(wu+k-(dfn[tp[u]]-dfn[u]+1)%k)%k;        u=fa[tp[u]];    &#125;    if (dep[u]&lt;dep[v]) swap(u,v),swap(wu,wv);    ans+=query(dfn[u],dfn[v],k,wu);    return ans;&#125;int main()&#123;    n=read();    for (int i&#123;1&#125;;i&lt;=n;++i)        scanf(&quot;%d&quot;,a+i);    for (int i&#123;1&#125;;i&lt;n;++i) &#123;        int a&#123;read()&#125;,b&#123;read()&#125;;        e[a].push_back(b);        e[b].push_back(a);    &#125;    fz_init(1,0);fz_cut(1,1);    for (int i&#123;1&#125;;i&lt;=n;++i)        dfn[i]=n-dfn[i]+1;    for (int i&#123;1&#125;;i&lt;=n;++i)        val[dfn[i]]=a[i];    for (int k&#123;1&#125;;k&lt;K;++k)        for (int i&#123;2&#125;;i&lt;bl(n);++i)            for (int j&#123;L(i)&#125;;j&lt;=R(i);++j)                sum[i][k][(j-L(i)+1)%k]+=val[j];    for (int i&#123;1&#125;;i&lt;=n;++i)        a[i]=read();    for (int i&#123;1&#125;;i&lt;n;++i) &#123;        int w&#123;read()&#125;;        printf(&quot;%d\n&quot;,query(a[i],a[i+1],w));    &#125;    return 0;&#125;</code></pre><p>随便跑跑就最优解第一页了。</p>]]></content>
      
      
      <categories>
          
          <category> solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO17JAN]Promotion Counting P 题解</title>
      <link href="/p/solution-p3605/"/>
      <url>/p/solution-p3605/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3605">题目传送门</a></p><p>线段树合并+动态开点（指针党福利）</p><span id="more"></span><p>在值域上开线段树为啥要离散化啊，我不能理解</p><p>所以这是一份无需离散化的题解。</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;using namespace std;struct tnode&#123;    tnode *l,*r;    // 该区间数的个数    int cnt;&#125;;using pnode=tnode*;// 哨兵节点pnode nil&#123;new tnode&#123;nil,nil,0&#125;&#125;;void check(pnode&amp; p)&#123;if(p==nil)p=new tnode&#123;nil,nil,0&#125;;&#125;// insert操作。cnt为当前区间size，使用了类似第k大的写法void modify(pnode&amp; p,int k,int cnt)&#123;    check(p);++p-&gt;cnt;    if (cnt==1) return;    int cq&#123;cnt&gt;&gt;1&#125;;    if (k&lt;=cq) modify(p-&gt;l,k,cq);    else modify(p-&gt;r,k-cq,cnt-cq);&#125;void merge(pnode&amp; p,pnode q)&#123;    if (q==nil) return;    if (p==nil)    &#123;        p=q;        return;    &#125;    p-&gt;cnt+=q-&gt;cnt;    merge(p-&gt;l,q-&gt;l);merge(p-&gt;r,q-&gt;r);    // 垃圾回收    delete q;&#125;// 查询大于k的数的个数int query(pnode p,int k,int L,int R)&#123;    if (p==nil||L&gt;k) return p-&gt;cnt;    int mid&#123;L+R&gt;&gt;1&#125;;    // 显然如果k在右儿子里就只用查询右儿子，否则只用查询左儿子    // 同样类似第k大    if (k&gt;=mid-1) return query(p-&gt;r,k,mid,R);    else return p-&gt;r-&gt;cnt+query(p-&gt;l,k,L,mid);&#125;const int N(1e5);int v[N+5],r[N+5];vector&lt;int&gt; e[N+5];pnode fz(int u)&#123;    pnode p&#123;nil&#125;;    for (auto v:e[u])        merge(p,fz(v));    r[u]=query(p,v[u],1,1e9+1);    modify(p,v[u],1e9);    return p;&#125;int main()&#123;    int n;cin&gt;&gt;n;    for (int i&#123;1&#125;;i&lt;=n;++i)        scanf(&quot;%d&quot;,v+i);    for (int i&#123;2&#125;;i&lt;=n;++i)    &#123;        int fa;scanf(&quot;%d&quot;,&amp;fa);        e[fa].push_back(i);    &#125;    fz(1);    for (int i&#123;1&#125;;i&lt;=n;++i) printf(&quot;%d\n&quot;,r[i]);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[POI2008]POC-Trains 题解</title>
      <link href="/p/solution-p3471/"/>
      <url>/p/solution-p3471/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3471">题目传送门</a></p><p>这是一个 $O(nl+m)$ 的做法（即和输入同阶）。</p><span id="more"></span><p>首先，看到字符串相同显然想到哈希。我们开一个哈希表，每个键值维护一个 <code>size</code>。对于每次修改，从表中原位置删除，重新计算哈希然后插入到新位置。</p><p>更新的话，只要在删除的时候查一下在当前的键值下，从插入到现在这段时间中 <code>size</code> 的最大值。</p><p>所以，我们只需要在线支持如下操作：</p><ul><li>查询后缀最大值</li><li>在结尾插入一个数</li></ul><p>显然可以开一个并查集维护（如果不会带权并查集可以看<a href="https://www.luogu.com.cn/blog/374433/union-find">这个</a>）。</p><pre><code class="lang-cpp">// 返回的不是祖先而是 `x` 这个点的后缀最大值（其实所有点的祖先都是最后插入的数）int Find(int u,int x)&#123;    if (dsu[u][x].fa==x) return dsu[u][x].mx;    dsu[u][x].mx=max(dsu[u][x].mx,Find(u,dsu[u][x].fa));    dsu[u][x].fa=dsu[u][dsu[u][x].fa].fa;    return dsu[u][x].mx;&#125;void insert(int x)&#123;    int H&#123;h[x]&#125;;// h[x] 为串 x 的哈希    // 动态开 vector，主要是开表大小个 vector 内存会炸    if (!F[H]) F[H]=cnt++;    // 插入的位置（即删除时要查询的位置）    lst[x]=dsu[F[H]].size();    ++sz[H];    // 将前面的树 merge 到新插入的点    if (lst[x]) dsu[F[H]][lst[x]-1].fa=lst[x];    // 插入新节点    dsu[F[H]].emplace_back(lst[x],sz[H]);&#125;</code></pre><p>因为只有一棵树且没有 <code>merge</code>，所以这份并查集的复杂度是线性的。</p><p>最后还要再更新一下最大值。</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;using namespace std;const int bn&#123;2579&#125;,b6e0&#123;25165843&#125;;const int N(1e3),M(1e5);int sz[b6e0],res[N];int lst[N];int F[b6e0];struct node&#123;    int fa,mx;    node(int _fa=0,int _mx=0):fa&#123;_fa&#125;,mx&#123;_mx&#125;&#123;&#125;&#125;;vector&lt;node&gt; dsu[N+M];int cnt;int h[N],pl[N],l;string s[N];int Find(int u,int x)&#123;    if (dsu[u][x].fa==x) return dsu[u][x].mx;    dsu[u][x].mx=max(dsu[u][x].mx,Find(u,dsu[u][x].fa));    dsu[u][x].fa=dsu[u][dsu[u][x].fa].fa;    return dsu[u][x].mx;&#125;void fresh(int x,int p,int n)&#123;    h[x]=(h[x]+1LL*pl[l-p-1]*(n-s[x][p])%b6e0)%b6e0;    if (h[x]&lt;0) h[x]=(h[x]+b6e0)%b6e0;    s[x][p]=n;&#125;void upd(int x)&#123;    int H&#123;h[x]&#125;;    if (!F[H]) F[H]=cnt++;    lst[x]=dsu[F[H]].size();    ++sz[H];    if (lst[x]) dsu[F[H]][lst[x]-1].fa=lst[x];    dsu[F[H]].emplace_back(lst[x],sz[H]);&#125;int main()&#123;    int n,m;cin&gt;&gt;n&gt;&gt;l&gt;&gt;m;    for (int i&#123;0&#125;;i&lt;n;++i)    &#123;        cin&gt;&gt;s[i];        for (char c:s[i])            h[i]=(1LL*h[i]*bn%b6e0+c-&#39;a&#39;)%b6e0;        upd(i);     &#125;    pl[0]=1;    for (int i&#123;1&#125;;i&lt;=l;++i)        pl[i]=1LL*pl[i-1]*bn%b6e0;    while (m--)    &#123;        int a,i,b,j;        scanf(&quot;%d %d %d %d&quot;,&amp;a,&amp;i,&amp;b,&amp;j);        --a;--i;--b;--j;        --sz[h[a]];res[a]=max(res[a],Find(F[h[a]],lst[a]));        if (a!=b) --sz[h[b]],res[b]=max(res[b],Find(F[h[b]],lst[b]));        char x&#123;s[a][i]&#125;,y&#123;s[b][j]&#125;;        fresh(a,i,y);fresh(b,j,x);        upd(a);if (a!=b) upd(b);    &#125;    for (int i&#123;0&#125;;i&lt;n;++i)        cout&lt;&lt;max(res[i],Find(F[h[i]],lst[i]))&lt;&lt;endl;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO22OPEN]COW Operations S 题解</title>
      <link href="/p/solution-p8271/"/>
      <url>/p/solution-p8271/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8271">题目传送门</a></p><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><p>首先，三个字母是可以随意交换的，所以先用 <code>XYZ</code> 代替 <code>COW</code>。</p><span id="more"></span><p>枚举易得以下性质（<code>=&gt;</code> 意为<strong>变换后答案不变</strong>，<code>=x&gt;</code> 反之，<code>E</code> 表示空串）：</p><ol><li><code>X =x&gt; Y</code></li><li><code>XY =x&gt; X/Y</code></li><li><code>XYZ =x&gt; X/Y/Z</code></li><li><code>XX =x&gt; X</code></li><li><code>XY =&gt; Z</code>（逆运算）</li><li><code>E =&gt; XX</code>（逆运算）</li></ol><p>整合一下就得到了三个字母各最多有一个的解决方案：</p><div class="table-container"><table><thead><tr><th style="text-align:center">$s$</th><th style="text-align:center">$ans$</th><th style="text-align:center">理由</th></tr></thead><tbody><tr><td style="text-align:center"><code>E</code></td><td style="text-align:center"><code>N</code></td><td style="text-align:center">性质 4、6</td></tr><tr><td style="text-align:center"><code>C</code></td><td style="text-align:center"><code>Y</code></td><td style="text-align:center">-</td></tr><tr><td style="text-align:center"><code>O</code></td><td style="text-align:center"><code>N</code></td><td style="text-align:center">性质 1</td></tr><tr><td style="text-align:center"><code>W</code></td><td style="text-align:center"><code>N</code></td><td style="text-align:center">性质 1</td></tr><tr><td style="text-align:center"><code>CO</code></td><td style="text-align:center"><code>N</code></td><td style="text-align:center">性质 2</td></tr><tr><td style="text-align:center"><code>CW</code></td><td style="text-align:center"><code>N</code></td><td style="text-align:center">性质 2</td></tr><tr><td style="text-align:center"><code>OW</code></td><td style="text-align:center"><code>Y</code></td><td style="text-align:center">性质 5</td></tr><tr><td style="text-align:center"><code>COW</code></td><td style="text-align:center"><code>N</code></td><td style="text-align:center">性质 3</td></tr></tbody></table></div><p>于是我们的目标变为：尝试将字符串 $s$ 简化为上述情况中的一种。</p><hr><p>接下来，让我们请出伟大的性质  7：</p><ol><li><code>XY =&gt; Z =&gt; YX</code>（性质 5）</li><li><code>XX =&gt; XX</code></li></ol><p>也就是说，<strong>任意两个相邻的的字符可以互相交换</strong>。</p><p>这意味着什么呢？</p><p>冒泡排序学过没？</p><p>也就是说，<strong>这个字符串可以被任意的重新排列</strong>。</p><p>相信到这里各位都会做了。</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>我们将字符串 $s$ 排序，把相邻的删掉，最后每种字符最多有一个。完了。</p><p>用前缀和处理一下，对于每个询问，统计区间内的三个字符的个数除以 2 的余数，再根据上面的表格求出答案就行了。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN(2e5+5);int sum[MAXN][3];int c[&#39;~&#39;];int main()&#123;    c[&#39;C&#39;]=0;c[&#39;O&#39;]=1;c[&#39;W&#39;]=2;    string s;cin&gt;&gt;s;    for (int i&#123;1&#125;;i&lt;=s.size();++i)    &#123;        for (int j&#123;0&#125;;j&lt;3;++j) sum[i][j]+=sum[i-1][j];        ++sum[i][c[s[i-1]]];    &#125;    int T;cin&gt;&gt;T;    while (T--)    &#123;        int l,r;scanf(&quot;%d %d&quot;,&amp;l,&amp;r);        int z[3];        for (int i&#123;0&#125;;i&lt;3;++i)            z[i]=sum[r][i]-sum[l-1][i]&amp;1;        printf(&quot;%c&quot;,!(z[1]^z[2])&amp;&amp;(z[0]^z[1])?&#39;Y&#39;:&#39;N&#39;);    &#125;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 迭代器，了解一下？（2）</title>
      <link href="/p/iterator/"/>
      <url>/p/iterator/</url>
      
        <content type="html"><![CDATA[<p>本文将<a href="https://www.luogu.com.cn/blog/poi/cpp-iterator">C++ 迭代器，了解一下？</a> 中一笔带过的一些东西讲了一下。</p><p>本文介绍三种特殊的迭代器。除了反向迭代器，都需要包含头文件 <code>iterator</code> 。而反向迭代器需要包含相关容器的头文件。</p><p>本文的代码均使用 <code>C++11</code> 标准。</p><span id="more"></span><h2 id="0-前置芝士"><a href="#0-前置芝士" class="headerlink" title="0. 前置芝士"></a>0. 前置芝士</h2><ul><li><p>标准库函数</p></li><li><p>模板及相关操作</p></li><li><p>普通迭代器的使用</p></li></ul><h2 id="1-反向迭代器"><a href="#1-反向迭代器" class="headerlink" title="1. 反向迭代器"></a>1. 反向迭代器</h2><p>反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器，它也是每个容器自己定义的。</p><p>对于所有支持反向迭代器的容器，我们都可以通过调用 <code>rbegin()</code> 以及 <code>rend()</code> 来获取反向迭代器。<code>rbegin()</code> 返回一个指向尾元素的迭代器，而 <code>rend()</code> ·返回一个首元素前一个元素的迭代器。</p><p>下图为在 <code>vector</code> 中，四个迭代器位置的关系。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/1qwxfmva.png" alt="图片炸了"></p><p>对于反向迭代器，递增操作的含义会倒过来，如 <code>++it</code> 会使 <code>it</code> 移动到前一个元素。</p><p>那么为什么如此定义递增呢？因为这样实现的话，我们在操作迭代器时，就无需知道迭代器是正向还是反向。</p><pre><code class="lang-C++">// 此代码为一个反向迭代器的例子。// 输出：// 1 2 3 4 5 6 7 8 9// 9 8 7 6 5 4 3 2 1#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;// 一个打印函数template &lt;typename T&gt;void print(T beg, T end)&#123;    for (T it = beg; it != end; ++it)        cout &lt;&lt; *it &lt;&lt; &#39; &#39;;    cout &lt;&lt; endl;&#125;int main()&#123;    vector&lt;int&gt; v = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;    print(v.begin(), v.end());    print(v.rbegin(), v.rend());    return 0;&#125;</code></pre><p>如上述代码所示，我们不需要为反向迭代器单独编写一份打印函数。这正是泛型编程的特点之一。</p><h3 id="反向迭代器和普通迭代器的关系"><a href="#反向迭代器和普通迭代器的关系" class="headerlink" title="反向迭代器和普通迭代器的关系"></a>反向迭代器和普通迭代器的关系</h3><p>如果我们需要将一个反向迭代器转化为正向的，应该如何操作？</p><p>可以使用成员函数 <code>base()</code>。</p><p>例如，我们需要在一个 <code>vector</code> 中打印最后一个 <code>0</code> 之后的数字。</p><pre><code class="lang-c++">// 一个神奇的示例// 输出：3 7 2 1#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123;    vector&lt;int&gt; v = &#123;3, 5, 4, 0, 2, 6, 0, 3, 7, 2, 1&#125;;    auto last0 = find(v.rbegin(), v.rend(), 0);    for (auto it = last0.base(); it != v.end(); ++it)        cout &lt;&lt; *it &lt;&lt; &#39; &#39;;    cout &lt;&lt; endl;    return 0;&#125;</code></pre><p>这个程序有一个问题：在转换迭代器的时候，并未跳过 <code>0</code>，所以 <code>it</code> 被初始化的时候，应该第一个输出 <code>0</code>。可是它没有。</p><p>这说明：<strong>反向迭代器在转换后有移位</strong>。</p><p>为什么会有这种情况呢？</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/1qwxfmva.png" alt="图片炸了"><br>（没错还是这张图）</p><p>假设反向迭代器转换后不会移位的话：</p><ul><li><p>如果转换 <code>rend()</code>，它对应什么？</p></li><li><p>转换哪一个反向迭代器，能使它变成 <code>end()</code>？</p></li></ul><p>所以我们得出结论：为了保证<strong>一一对应</strong>，在转换后，<code>rbegin()</code> 变成 <code>end()</code>，<code>rend()</code> 变成 <code>begin()</code>。</p><p>这就是移位的由来。</p><p>还有一个问题：那普通迭代器如何转为反向迭代器？</p><p>答：反向迭代器有一个构造函数，传入一个普通迭代器。</p><p>如：</p><pre><code class="lang-c++">vector&lt;int&gt; v = &#123;2, 1, 3&#125;;auto it = v.begin();vector&lt;int&gt;::reverse_iterator rit(it); //rit 指向 rend()</code></pre><p>（不过这样比 <code>auto</code> 累多了</p><h2 id="2-iostream-迭代器"><a href="#2-iostream-迭代器" class="headerlink" title="2. iostream 迭代器"></a>2. <code>iostream</code> 迭代器</h2><p>这是极为特殊的一种迭代器。<code>iostream</code> 迭代器（或流迭代器）可以绑定流以进行输入输出。流迭代器可以通用化、简化输入输出。</p><h3 id="istream-iterator"><a href="#istream-iterator" class="headerlink" title="istream_iterator"></a><code>istream_iterator</code></h3><p>当创建一个输入流迭代器的时候，可以绑定一个流，如 <code>cin</code>。但是不一定。未绑定的迭代器可以当作 <code>EOF</code> 使用，也可以成为 <code>IO</code> 错误的判定。 </p><p>下面是一个例子：</p><pre><code class="lang-c++">vector&lt;int&gt; v;istream_iterator&lt;int&gt; in(cin), eof;while (in!=eof)    v.push_back(*in++);</code></pre><p>它等价于</p><pre><code class="lang-c++">vector&lt;int&gt; v;int x;while (cin &gt;&gt; x)    v.push_back(x);</code></pre><p>但其实 <code>vector</code> 有一个接受两个·迭代器版本的构造函数，所以我们还可以写成如下形式：</p><pre><code class="lang-c++">istream_iterator&lt;int&gt; in(cin), eof;vector&lt;int&gt; v(in, eof);</code></pre><p>这体现了流迭代器的简便之处。</p><p>下表列出了输入流迭代器支持的操作（<code>ii&lt;T&gt;</code> 表示 <code>istream_iterator&lt;T&gt;</code>）：<br>|||<br>|—-|—-|<br>|<code>ii&lt;T&gt; in(is);</code>|<code>in</code> 从输入流 <code>is</code> 读入类型为 <code>T</code> 的值|<br>|<code>ii&lt;T&gt; end;</code>|读入类型为 <code>T</code> 的值的输入流迭代器，表示尾后位置|<br>|<code>in1 == in2</code>|<code>in1</code> 和 <code>in2</code> 必须读取相同类型。如果它们绑定了同一个流，或都为尾后位置则为真|<br>|<code>in1 != in2</code>|见 <code>in1 == in2</code>|<br>|<code>*in</code>|返回从流中读取的值|<br>|<code>++in, in++</code>|使用元素定义的运算符 <code>&gt;&gt;</code> 读取下一个值|</p><p>我们还可以使用任何传入输入迭代器的标准库算法，下面是一个例子：</p><pre><code class="lang-c++">istream_iterator&lt;int&gt; in(cin), eof;cout &lt;&lt; accumulate(in, eof, 0) &lt;&lt; endl;</code></pre><p>其中 <code>accumulate</code> 函数负责求和。在这里，它表示 <code>0</code> 加上从 <code>in</code> 到 <code>eof</code> 之前（即在文件尾或非法输入之前输入的 <code>int</code>）的和。</p><p>如输入：<br><code>1 2 3 4 5 6 7 8 9</code></p><p>则输出 <code>45</code>。</p><h3 id="ostream-iterator"><a href="#ostream-iterator" class="headerlink" title="ostream_iterator"></a><code>ostream_iterator</code></h3><p>输出流迭代器类似输入，但不支持尾后元素（即默认构造）。创建一个输出流迭代器时，提供一个可选的第二参数，它是一个字符串，表示每次输出后打印的字符串。它必须是一个 <code>C</code> 风格字符串。</p><p>输出流迭代器支持的所有操作如下表（其中 <code>oi&lt;T&gt;</code> 表示 <code>ostream_iterator&lt;T&gt;</code>）：</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><code>oi&lt;T&gt; out(os)</code></td><td><code>out</code> 将类型为 <code>T</code> 的值输出到 <code>os</code> 中</td></tr><tr><td><code>oi&lt;T&gt; out(os,d)</code></td><td>同上，但每次输出后都再输出一个 <code>d</code>，<code>d</code> 是一个 <code>C</code> 风格字符串</td></tr><tr><td><code>out = val</code></td><td>用 <code>&lt;&lt;</code> 运算符将 <code>val</code> 写入到 <code>out</code> 绑定的流中</td></tr><tr><td><code>*out, ++out, out++</code></td><td>这些运算符是存在的，但不对 <code>out</code> 做任何事情。每个运算符都返回 <code>out</code></td></tr></tbody></table></div><p>其中最后一条是为了更好的写出泛型代码，就如同之前提到的反向迭代器的递增操作。</p><pre><code class="lang-c++">ostream&lt;int&gt; out(cout,&quot; &quot;); //注意不要传入字符！for (auto i : v) //v 是一个 vector    *out++ = i; //等价于 out = i，但这样的操作更普遍、更易懂</code></pre><p>同样的，输出流迭代器也有更好的使用方法，那就是把循环替换为标准库算法：</p><p><code>copy(v.begin(), v.end(), out);</code></p><h3 id="例题：A-B-Problem"><a href="#例题：A-B-Problem" class="headerlink" title="例题：A+B Problem"></a>例题：<a href="https://www.luogu.com.cn/problem/P1001">A+B Problem</a></h3><p>让我们用流迭代器解决解决这个问题<a href="https://www.luogu.com.cn/record/55312776">（或成为全谷最臭代码</a>：</p><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123;    ostream_iterator&lt;int&gt; out(cout,&quot;\n&quot;);    istream_iterator&lt;int&gt; in(cin);    int a = *in++;    int b = *in++;    out = a + b;    return 0;&#125;</code></pre><p>您也可以尝试使用前文提到的 <code>accumulate</code> 函数（需要头文件 <code>numeral</code>）来收获更短的代码，或改用 <code>cout</code> 来收获更更短的代码。</p><h2 id="3-插入迭代器"><a href="#3-插入迭代器" class="headerlink" title="3. 插入迭代器"></a>3. 插入迭代器</h2><p>插入迭代器是一个很神奇的东西。例如下面的代码</p><pre><code class="lang-c++">vector&lt;int&gt; v1 = &#123;0, 1, 2, 3&#125;;vector&lt;int&gt; v2(v1.size());copy(v1.begin(), v1.end(), v2.begin());</code></pre><p>实际上可以简化成如下代码：</p><pre><code class="lang-c++">vector&lt;int&gt; v1 = &#123;0, 1, 2, 3&#125;;vector&lt;int&gt; v2;copy(v1.begin(), v2.end(), back_inserter(v2));</code></pre><p>不难发现，<code>back_inserter</code> 返回一个迭代器，但它本身并不是一个迭代器。实际上，“插入迭代器”都是<strong>迭代器适配器</strong>（相关概念请自行 BFS）。</p><p>下表列出了插入迭代器返回的迭代器的操作：</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><code>it = t</code></td><td>在 <code>it</code> 的指定位置插入元素</td></tr><tr><td><code>*it, ++it, it++</code></td><td>这些运算符是存在的，但不对 <code>it</code> 做任何事情。每个运算符都返回 <code>it</code></td></tr></tbody></table></div><p>对于“指定位置”有：</p><ul><li><p><code>front_inserter</code> 等价于调用 <code>push_front</code>;</p></li><li><p><code>back_inserter</code> 等价于调用 <code>push_back</code>;</p></li><li><p><code>inserter</code> 接受一个第二参数，它是一个迭代器 <code>it</code>，等价于调用 <code>insert</code>，且插入位置在 <code>it</code> 的前面。</p></li></ul><pre><code class="lang-c++">// 三种 inserter 的示例// 输出：// 5 1 2 3 4// 4 3 2 1 5// 1 2 3 4 5#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;algorithm&gt;#include &lt;iterator&gt;using namespace std;void print(list&lt;int&gt; l)&#123;    ostream_iterator&lt;int&gt; out(cout, &quot; &quot;);    copy(l.begin(), l.end(), out);    cout &lt;&lt; endl;&#125;int main()&#123;    list&lt;int&gt; l = &#123;1, 2, 3, 4&#125;;    list&lt;int&gt; l1 = &#123;5&#125;, l2 = &#123;5&#125;, l3 = &#123;5&#125;; // 空 list    copy(l.begin(), l.end(), back_inserter(l1));    copy(l.begin(), l.end(), front_inserter(l2));    copy(l.begin(), l.end(), inserter(l3, l3.begin())); // 在 l3.begin() 前面插入    print(l1);    print(l2);    print(l3);    return 0;&#125;</code></pre><p>实际上，这些迭代器也可以存下来：</p><p><code>auto bit=back_inserter(v);</code></p><p>同时，只有支持对应操作的容器才能使用。</p><h2 id="4-参考文献"><a href="#4-参考文献" class="headerlink" title="4. 参考文献"></a>4. 参考文献</h2><p><em>C++ Primer 5th edition</em></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈c++中的set与map家族</title>
      <link href="/p/set-and-map/"/>
      <url>/p/set-and-map/</url>
      
        <content type="html"><![CDATA[<p>众所周知，<code>set</code> 和 <code>map</code> 是两种常用的 STL 容器。</p><span id="more"></span><h2 id="0-说句闲话"><a href="#0-说句闲话" class="headerlink" title="0. 说句闲话"></a>0. 说句闲话</h2><h3 id="前置芝士："><a href="#前置芝士：" class="headerlink" title="前置芝士："></a>前置芝士：</h3><ul><li><code>set</code> 与 <code>map</code> 的熟练使用，包括遍历</li></ul><h3 id="本文包含以下内容："><a href="#本文包含以下内容：" class="headerlink" title="本文包含以下内容："></a>本文包含以下内容：</h3><div class="table-container"><table><thead><tr><th></th><th>不排序</th><th>不去重</th></tr></thead><tbody><tr><td><code>set</code></td><td><code>unordered_set</code></td><td><code>multiset</code></td></tr><tr><td><code>map</code></td><td><code>unordered_map</code></td><td><code>multimap</code></td></tr></tbody></table></div><p>并且全部为 <code>C++11</code> 标准中的内容。</p><h2 id="1-不排序"><a href="#1-不排序" class="headerlink" title="1. 不排序"></a>1. 不排序</h2><p><code>set</code> 和 <code>map</code> 都是用红黑树实现的，虽然是 $\log n$，但还是比较慢的。</p><p><code>unordered_set</code> 就会快很多，它不使用平衡树，而是用哈希实现，复杂度 $O(1)$。</p><p>由于是把相同哈希值的元素放在一起，遍历时没有顺序。<strong>并不保证按输入顺序输出</strong>。</p><pre><code class="lang-c++">#include &lt;unordered_set&gt; //bits 也可以using namespace std;...unordered_set &lt;int&gt; s;s.insert(9);s.insert(2);s.insert(1);s.insert(9);s.insert(8);s.insert(7);for (auto i : s)    cout &lt;&lt; i &lt;&lt; &#39; &#39;;...</code></pre><p>输出：</p><pre><code>7 8 1 9 2</code></pre><p>注意 <code>unordered_set</code> 仍然会进行去重。</p><p><code>find()</code>、<code>count()</code>、<code>size()</code>等和 <code>set</code> 无区别。</p><p><code>unordered_map</code> 同 <code>unordered_set</code>，但是使用 <code>operator[]</code> 时属于修改，后插入的会替换之前的。</p><pre><code class="lang-c++">#include &lt;unordered_map&gt; //bits 也可以using namespace std;...unordered_map &lt;int, int&gt; m;m.insert(make_pair(9, 8)); //其实 map &lt;Ta, Tb&gt; 可以当作 set &lt;pair &lt;Ta, Tb&gt; &gt;m.insert(make_pair(9, 2));m.insert(make_pair(1, 7));m.insert(make_pair(2, 0));m.insert(make_pair(0, 2));m.insert(make_pair(1, 6));++m[0];m[4]=6;m[4]=7;for(auto i : m)    cout &lt;&lt; i.first &lt;&lt; &#39; &#39; &lt;&lt; i.second &lt;&lt; endl;...</code></pre><p>输出：</p><pre><code>4 70 32 09 81 7</code></pre><h2 id="2-不去重"><a href="#2-不去重" class="headerlink" title="2. 不去重"></a>2. 不去重</h2><p><code>multiset</code> 和 <code>set</code> 基本一致，但是它不会去重。</p><p>所以调用 <code>find()</code> 会返回第一个符合要求的（插入顺序），而 <code>count()</code> 会返回所有符合要求的。</p><pre><code class="lang-c++">#include &lt;set&gt;using namespace std;...multiset &lt;int&gt; s;s.insert(9);s.insert(7);s.insert(9);s.insert(8);s.insert(1);s.insert(7);for (auto i : s)    cout &lt;&lt; i &lt;&lt; &#39; &#39;;...</code></pre><p>输出：</p><pre><code>1 7 7 8 9 9</code></pre><p><code>multimap</code> 同 <code>multiset</code>，且没有定义 <code>operator[]</code>。</p><pre><code class="lang-c++">#include &lt;map&gt;using namespace std;...multimap &lt;int, int&gt; m;m.insert(&#123;9, 1&#125;);m.insert(&#123;2, 3&#125;);m.insert(&#123;3, 3&#125;);m.insert(&#123;8, 0&#125;);m.insert(&#123;9, 1&#125;);m.insert(&#123;3, 2&#125;);for (auto &amp;i : m)    cout &lt;&lt; i.first &lt;&lt; &#39; &#39; &lt;&lt; i.second &lt;&lt; endl;...</code></pre><p>输出：</p><pre><code>2 33 33 28 09 19 3</code></pre><p>注意相同键值按插入顺序排列。</p><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>相信一定有人问了：有没有既不排序、也不去重的 <code>set</code> / <code>map</code> 呢？</p><p>有！</p><p><del><code>vector</code></del> <code>unordered_multiset</code> / <code>unordered_multimap</code> 就满足这个要求。</p><p>而且，只要人品好，哈希值不怎么冲突，什么操作都是 $O(1)$ ，吊打 <code>vector</code>（特别是插入与删除）。</p><p>这不是本文的重点，有兴趣的巨佬可以自行研究。</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo theme cutie v2.x tutorial</title>
      <link href="/p/hello-world/"/>
      <url>/p/hello-world/</url>
      
        <content type="html"><![CDATA[<p><img src="images/tree.png" alt="cover"></p><p>Theme cutie has evolved from v1.x to v2.x with a refreshed and fine tuned design and more features. Follow the following instruction to install and use it. You may navigate this website to experience the new look and interaction of v2.x.</p><p><strong>Thank you for your stars and support</strong>.</p><span id="more"></span><h1 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h1><h2 id="Install-for-a-new-site"><a href="#Install-for-a-new-site" class="headerlink" title="Install for a new site"></a>Install for a new site</h2><p>Prerequiste<br>:   Make sure you install <code>node.js</code> and <code>hexo</code> through command line. Refer to official Hexo doc for detailed instruction.</p><p>Working directory<br>:   Make sure your terminal (command line) is currently in the folder where you want to create the site.</p><p>Installation steps<br>:   The first step is the standard hexo installation step. If you have done them, skip to step 2.  </p><pre><code>1. Initialize your site```bashhexo init your-site-foldercd your-site-foldernpm install```2. [_Optional_][_Recommended_] Uninstall `hexo-renderer-marked` and install `hexo-renderer-markdown-it` and associated plugins.```bashnpm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --savenpm i markdown-it-emoji --savenpm i markdown-it-mark --savenpm i markdown-it-deflist --savenpm i markdown-it-container --save```3. Download [latest theme cutie](https://github.com/qutang/hexo-theme-cutie/releases/latest) and unzip it to `themes/` folder in your site. Then rename it to `cutie`.</code></pre><p>Initial configuration file<br>:   <code>_config.yml</code> in the root path of your site.</p><p>Initial configuration<br>:   1. Follow standard hexo initial configuration: <a href="https://hexo.io/docs/configuration.html">https://hexo.io/docs/configuration.html</a></p><pre><code>2. Add variables or modify the variables in your `_config.yml` according to following snippet.    ```yml _config.yml    highlight:      enable: true      line_number: true      auto_detect: false      tab_replace:     markdown:      render:        html: true        xhtmlOut: false        breaks: false        linkify: true        typographer: true        quotes: &#39;“”‘’&#39;      plugins:        - markdown-it-abbr        - markdown-it-footnote        - markdown-it-ins        - markdown-it-sub        - markdown-it-sup        - markdown-it-deflist      anchors:        level: 1        collisionSuffix: &#39;v&#39;        permalink: false        permalinkClass: header-anchor        permalinkSymbol: &quot;&quot;        permalinkBefore: false    date_format: ll    archive_generator:      per_page: 0      yearly: true      monthly: false      daily: false    theme: cutie    ```</code></pre><p>Bring site alive<br>:   ```bash<br>    hexo s —debug</p><pre><code>```</code></pre><h2 id="Install-for-an-existing-site"><a href="#Install-for-an-existing-site" class="headerlink" title="Install for an existing site"></a>Install for an existing site</h2><p>Working directory<br>:   Make sure your terminal (command line) is currently in the root folder of the site.</p><p>Installation steps<br>:</p><ol><li><p>[<em>Optional</em>][<em>Recommended</em>] Uninstall <code>hexo-renderer-marked</code> and install <code>hexo-renderer-markdown-it</code> and associated plugins.</p><pre><code> ```bash npm un hexo-renderer-marked --save npm i hexo-renderer-markdown-it --save npm i markdown-it-emoji --save npm i markdown-it-mark --save npm i markdown-it-deflist --save npm i markdown-it-container --save ```</code></pre></li><li><p>Download <a href="https://github.com/qutang/hexo-theme-cutie/releases/latest">latest theme cutie</a><br>and unzip it to <code>themes/</code> folder in your site. Then rename it to <code>cutie</code>.</p></li></ol><p>Initial configuration file<br>:   <code>_config.yml</code> in the root path of your site.</p><p>Initial configuration<br>:   1. Follow standard hexo initial configuration: <a href="https://hexo.io/docs/configuration.html">https://hexo.io/docs/configuration.html</a></p><pre><code>2. Add variables or modify the variables in your `_config.yml` according to following snippet.    ```yml _config.yml    highlight:      enable: true      line_number: true      auto_detect: false      tab_replace:     markdown:      render:        html: true        xhtmlOut: false        breaks: false        linkify: true        typographer: true        quotes: &#39;“”‘’&#39;      plugins:        - markdown-it-abbr        - markdown-it-footnote        - markdown-it-ins        - markdown-it-sub        - markdown-it-sup        - markdown-it-deflist      anchors:        level: 1        collisionSuffix: &#39;v&#39;        permalink: false        permalinkClass: header-anchor        permalinkSymbol: &quot;&quot;        permalinkBefore: false    date_format: ll    archive_generator:      per_page: 0      yearly: true      monthly: false      daily: false    theme: cutie    ```</code></pre><p>Bring site alive<br>:   ```bash<br>    hexo s —debug</p><pre><code>```</code></pre><h1 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h1><h2 id="From-v2-x"><a href="#From-v2-x" class="headerlink" title="From v2.x"></a>From v2.x</h2><p>Installation steps<br>:   1. Delete <code>themes/cutie/</code> folder in your site.</p><pre><code>2. Download the desired version of theme cutie from [release page](https://github.com/qutang/hexo-theme-cutie/releases), unzip it to `themes/` folder and rename it to `cutie`.</code></pre><p>Notes<br>:   There is a mimimal version requirement for each configuration, make sure your installed version is above it to use the corresponding configuration.</p><h2 id="From-v1-x"><a href="#From-v1-x" class="headerlink" title="From v1.x"></a>From v1.x</h2><p>Installation steps<br>:   1. Delete <code>themes/cutie/</code> folder in your site.</p><pre><code>2. Download the desired version of theme cutie from [release page](https://github.com/qutang/hexo-theme-cutie/releases), unzip it to `themes/` folder and rename it to `cutie`.</code></pre><p>Configuration<br>:   From v2.x, theme cutie uses <em>Hexo data file</em> (<code>sources/_data/cutie.yml</code>) to store all configurations, instead of using the <code>_config.yml</code> file of your site in v1.x. And the YAML structure has changed compared to v1.x. </p><pre><code>The recommendation is to configure the theme cutie from scratch using the following configuration guidelines.You may copy or reuse some configurations about theme cutie in your old `_config.yml` along the way. Please post an issue if you have hard time migrating your configurations from v1.x to v2.x.</code></pre><h1 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h1><h2 id="Language"><a href="#Language" class="headerlink" title="Language"></a>Language</h2><p>Minimal version<br>:   <em>Taurus</em>: <code>v2.0.0-alpha</code></p><p>Configuration file<br>:   <code>_config.yml</code> of site</p><p>Configuration format<br>:   Set <code>language</code> variable in your site’s <code>_config.yml</code> file.</p><pre><code>```yml _config.ymllanguage:- en- zh-cn- it```The first row will be your site&#39;s default language.</code></pre><p>Default configuration<br>:   If configuration is omitted, the default setting is <code>en</code>. Site will be displayed in English.</p><p>Notes<br>:   Currently, theme cutie only supports three languages: English, Italian and 简体中文.</p><p>Contributions<br>:   1. Italian translation is contributed by <a href="https://github.com/Fastbyte01">@fastbyte01</a></p><pre><code>2. More translation is welcomed if you are interested in contribution. You may add new language files in `themes/cutie/languages` folder according to Hexo&#39;s guideline: https://hexo.io/docs/internationalization.html and feel free to send me pull request.</code></pre><h2 id="Scheme"><a href="#Scheme" class="headerlink" title="Scheme"></a>Scheme</h2><p>This concept is from <code>hexo-theme-next</code>, the most popular theme for Hexo, in which it uses different themes for different layout design. In theme cutie, it follows the similar idea and provides the opportunity to choose different layout design using scheme.</p><p>Minimal version<br>:   <em>Taurus</em>: <code>v2.0.0-alpha</code></p><p>Configuration file<br>:   <code>source/_data/cutie.yml</code></p><p>Configuration format<br>:   Set <code>scheme</code> variable to scheme name to enable a theme scheme.</p><pre><code>```yml source/_data/cutie.ymlglobal:  scheme: Taurus # Avaliable values: Taurus```</code></pre><p>Default configuration<br>:   If configuration is omitted, the default setting is <code>Taurus</code>, scheme <code>Taurus</code> is enabled.</p><p>Notes<br>:   Currently, theme cutie only has <code>Taurus</code> theme, which is a two-column text-icon-based layout. Contribution is welcomed from developers or designers for new schemes.</p><p>For contributors<br>:   1. To add a new scheme, create a new file <code>your-scheme-name.css</code> in folder <code>themes/cutie/source/css/</code> and add your own scheme style in it.</p><pre><code>2. The system will automatically search for this css file and load it using the theme name `your-scheme-name` when changing the scheme configuration to `your-scheme-name`.</code></pre><h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><p>Minimal version<br>:   <code>v2.0.5-beta</code></p><p>Configuration file<br>:   <code>source/_data/cutie.yml</code></p><p>Configuration format<br>:   Set <code>use_animation</code> to <code>true</code> or <code>false</code> to enable or disable site animations.</p><pre><code>```yml source/_data/cutie.ymlglobal:  use_animation: true # Avaliable values: true, false```</code></pre><p>Default configuration<br>:   If configuration is omitted, the default setting is <code>true</code>, animation is enabled.</p><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><p>Theme cutie uses in-site search for the site. Use following steps to setup search page. Google custom search has been discarded since <code>v2.0.7</code>.</p><p>Minimal version<br>:   <code>v2.0.7</code></p><p>Configuration steps<br>:   1. No need for configuration, work out of box.</p><pre><code>2. If you are upgrading from versions below `v2.0.7`, delete the old search page you created for your site.</code></pre><h2 id="404-Page"><a href="#404-Page" class="headerlink" title="404 Page"></a>404 Page</h2><p>Theme cutie uses built-in 404 page. It supports a custom 404 art or tencent 404 charity page (腾讯404公益).</p><p>Minimal version<br>:   <code>v2.0.7</code></p><p>Configuration file<br>:   <code>source/_data/cutie.yml</code></p><p>Configuration steps<br>:   1. Delete the old <code>404.md</code> file of your site if you are upgrading from versions before <code>v2.0.7</code>.</p><pre><code>2. No need for configuration, work out of box. 3. You may configure the built-in 404 page to use 腾讯公益404 or not, by default it is NOT using 腾讯公益404.```yml source/_data/cutie.yml# set true to enable 腾讯公益404page_404:  tencent_404: true```</code></pre><h2 id="Social-network-links"><a href="#Social-network-links" class="headerlink" title="Social network links"></a>Social network links</h2><p>Minimal version<br>:   <code>v2.0.0-alpha</code></p><p>Configuration file<br>:   <code>source/_data/cutie.yml</code></p><p>Configuration format<br>:   Add social network names and links in the following format. Make sure the social network name matches the corresponding font awesome icon name. See <a href="https://fontawesome.com/icons?d=gallery&amp;s=brands">here</a> for the supported names and their icons.</p><pre><code>```yml source/_data/cutie.yml# As long as the name matches the font awesome icon name, you can add even more social linkssocial:  github: https://github.com/qutang  linkedin: https://www.linkedin.com/in/qutang```</code></pre><p>Default configuration<br>:   If configuration is omitted. No icons will be shown at the bottom right corner in the footer.</p><h2 id="Site-announcement"><a href="#Site-announcement" class="headerlink" title="Site announcement"></a>Site announcement</h2><p>Minimal version<br>:   <code>v2.0.7</code></p><p>Configuration file<br>:   <code>source/_data/cutie.yml</code></p><p>Configuration steps<br>:   1. Site announcement will display at the bottom left corner of home page as a purple box.</p><pre><code>2. Add following snippets to the configuration file to use, if omitted, site announcement is disabled.```yml source/_data/cutie.ymlglobal:  announcement:    text: This is a sample site announcement.```</code></pre><p>Notes<br>:   * The timeout duration for site announcement is 10s. The announcement popup will dismiss on click or on timeout.</p><pre><code>* You may use HTML markups in the announcement text. For example, you may add a link to the text.</code></pre><h2 id="Site-header"><a href="#Site-header" class="headerlink" title="Site header"></a>Site header</h2><h3 id="Setup-site-logo"><a href="#Setup-site-logo" class="headerlink" title="Setup site logo"></a>Setup site logo</h3><p>Minimal version<br>:   <code>v2.0.0-alpha</code></p><p>Configuration file<br>:   <code>sources/_data/cutie.yml</code></p><p>Configuration format<br>:   Set variable <code>logo</code> to your own icon’s link. Link can be either an external image link, or a relative link.</p><pre><code>```yml source/_data/cutie.ymllogo: /images/logo.svg```</code></pre><p>Default configuration<br>:   If configuration is omitted. the following image will be used as the logo image.</p><pre><code>![theme-icon](/images/logo.svg)</code></pre><h3 id="Setup-site-name-and-subtitle"><a href="#Setup-site-name-and-subtitle" class="headerlink" title="Setup site name and subtitle"></a>Setup site name and subtitle</h3><p>Minimal version<br>:   <code>v2.0.0-alpha</code></p><p>Configuration file<br>:   <code>_config.yml</code> of your site</p><p>Configuration format<br>:   Make sure your subtitle is not too log (better less than 30 characters).</p><pre><code>`title` is a standard Hexo configuration.`subtitle` is theme cutie&#39;s own configuration.```yml source/_data/cutie.ymltitle: Your site&#39;s titlesubtitle: Your site&#39;s subtitle```</code></pre><p>Default configuration<br>:   If configuration is omitted. You will not see any texts in the header.</p><p>Note<br>:   This configuration requires restarting the server.</p><h3 id="Setup-navigation-menu"><a href="#Setup-navigation-menu" class="headerlink" title="Setup navigation menu"></a>Setup navigation menu</h3><p>Minimal version<br>:   <code>v2.0.0-alpha</code></p><p>Configuration file<br>:   <code>sources/_data/cutie.yml</code></p><p>Configuration format<br>:   Add navigation item in the following format. link and icon can be external or internal. You can literally add any link to it.</p><pre><code>```yml source/_data/cutie.ymlmenu:  Resume:     link: /resume/  &quot;Menu item&quot;:    link: /aaa/```</code></pre><p>Default configuration<br>:   If configuration is omitted. No text links will show up in the header navigation menu or in the dropdown menu on any view.</p><p>Notes<br>:   1. If there are more than four menu items, only the first four will be shown in the header (on desktop view). However, you can find all menu items in the last dropdown menu.</p><pre><code>2. Do not use a very long menu item name. No more than three words, because there is some display issue when the name gets long.3. Compared with `v1.x`, menu icon is no longer supported.</code></pre><h2 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h2><h3 id="Use-Light-Gallery"><a href="#Use-Light-Gallery" class="headerlink" title="Use Light Gallery"></a>Use Light Gallery</h3><p>Theme cutie uses <a href="">Light Gallery</a> to support image modal display for <em>posts</em>. By default, it is enabled, but if you want to use other hexo plugins with similar functionality, you may want to disable it.</p><p>Minimal version<br>: <code>v2.0.5-beta</code></p><p>Configuration file<br>: <code>source/_data/cutie.yml</code></p><p>Configuration format<br>:   Set <code>use_lightgallery</code> to be <code>true</code> or <code>false</code> to enable or disable light gallery display for post images.</p><pre><code>```yml source/_data/cutie.ymlpost:  use_lightgallery: true```</code></pre><p>Default configuration<br>:   If configuration is omitted, by default light gallery is enabled for all posts.</p><p>Notes<br>:   It is currently not supported to enable or disable light gallery for an individual post.</p><h3 id="Use-post-version"><a href="#Use-post-version" class="headerlink" title="Use post version"></a>Use post version</h3><p>Theme cutie supports versioned post. Whenever the content of your post changes after you push your site, your visitors will see an unread badge on the post card in home page and archive pages.</p><p>Theme cutie uses Hashing and Cookie to track the post content change and the post content a visitor has last read. This feature does NOT use <code>leancloud</code> backend.</p><p>Minimal version<br>: <code>v2.0.8</code></p><h4 id="For-all-posts"><a href="#For-all-posts" class="headerlink" title="For all posts"></a>For all posts</h4><p>Configuration file<br>: <code>source/_data/cutie.yml</code></p><p>Configuration format<br>:   Set <code>enable_unread_badge</code> to be <code>true</code> to enable post versioning and unread badge or <code>false</code> to disable this feature for all the posts.</p><pre><code>```yml source/_data/cutie.yml---post:  enable_unread_badge: false---```</code></pre><p>Default configuration<br>:   If configuration is omitted, by default this feature is <strong>disabled</strong> for all posts.</p><h4 id="For-an-individual-post"><a href="#For-an-individual-post" class="headerlink" title="For an individual post"></a>For an individual post</h4><p>Configuration file<br>: A post’s front matter</p><p>Configuration format<br>:   Set <code>enable_unread_badge</code> to be <code>true</code> to enable post versioning and unread badge or <code>false</code> to disable this feature for the individual post.</p><pre><code>```yml post&#39;s front matter---enable_unread_badge: true---```</code></pre><p>Default configuration<br>:   If configuration is omitted, the setting will roll back to the unread badge setting for all the posts.</p><p>Notes<br>:   This setting has higher priority than the setting for all the posts.</p><h3 id="Setup-TOC-level"><a href="#Setup-TOC-level" class="headerlink" title="Setup TOC level"></a>Setup TOC level</h3><p>*[TOC]: Table of content</p><p>Minimal version<br>: <code>v2.0.5-beta</code></p><h4 id="For-all-posts-1"><a href="#For-all-posts-1" class="headerlink" title="For all posts"></a>For all posts</h4><p>Configuration file<br>: <code>source/_data/cutie.yml</code></p><p>Configuration format<br>:   Set <code>toc_level</code> under <code>post</code> to set the maximum level of headings in TOC for <em>all posts</em>. Allowed value is from <code>1</code> to <code>6</code>.</p><pre><code>```yml source/_data/cutie.ymlpost:  toc_level: 2```</code></pre><p>Default configuration<br>:  If this configuration is omitted, by default maximum TOC level is set to 2 (meaning <code>##</code> in markdown).</p><h4 id="For-an-individual-post-1"><a href="#For-an-individual-post-1" class="headerlink" title="For an individual post"></a>For an individual post</h4><p>Configuration file<br>:  A post’s front matter</p><p>Configuration format<br>:   Use variable <code>toc_level</code> to set the maximum level of headings in TOC for <em>an individual posts</em>. Allowed value is from <code>1</code> to <code>6</code>.</p><pre><code>```yml---toc_level: 2---```</code></pre><p>Default configuration<br>:   If variable is omitted in the post front matter, setting will fall back to the <a href="#for-all-posts">all-post-toc-setting</a>.</p><h3 id="Setup-post-comment"><a href="#Setup-post-comment" class="headerlink" title="Setup post comment"></a>Setup post comment</h3><p>Minimal version<br>:   <code>v2.0.5-beta</code></p><h4 id="For-all-posts-2"><a href="#For-all-posts-2" class="headerlink" title="For all posts"></a>For all posts</h4><p>Configuration file<br>: <code>source/_data/cutie.yml</code></p><p>Configuration format<br>:   Set <code>allow_comment</code> to be <code>true</code> or <code>false</code> to enable or disable comment section to be displayed for <em>all posts</em>.</p><pre><code>```yml source/_data/cutie.ymlpost:  allow_comment: true```</code></pre><p>Default configuration<br>:  If this configuration is omitted, by default comment section is enabled for all posts.</p><h4 id="For-an-individual-post-2"><a href="#For-an-individual-post-2" class="headerlink" title="For an individual post"></a>For an individual post</h4><p>Configuration file<br>:  A post’s front matter</p><p>Configuration format<br>:   Use variable <code>allow_comment</code> to enable or disable comment section.</p><pre><code>```yml---allow_comment: true---```</code></pre><p>Default configuration<br>:   If variable is omitted in the post front matter, setting will fall back to the <a href="#for-all-posts-v2">all-post-comment-setting</a>.</p><h3 id="Setup-post-copyright"><a href="#Setup-post-copyright" class="headerlink" title="Setup post copyright"></a>Setup post copyright</h3><p>Minimal version<br>:   <code>v2.0.5-beta</code></p><p>Theme cutie uses Creative Commons licenses for copyright configuration. We use three nested variables to cover the major licenses in Creative Commons.</p><ul><li><code>allow_share</code>: allow post to be shared (<code>true</code>) or not (<code>false</code>).<ul><li><code>allow_modification</code>: allow post to be modified while sharing when <code>true</code>.</li><li><code>allow_commercial</code>: allow post to be used for commercial purpose while sharing when <code>true</code>.</li></ul></li></ul><p>if <code>allow_share</code> is <code>false</code>, the other two variables will be ignored.</p><h4 id="For-all-posts-3"><a href="#For-all-posts-3" class="headerlink" title="For all posts"></a>For all posts</h4><p>Configuration file<br>: <code>source/_data/cutie.yml</code></p><p>Configuration format<br>:   Use the three variables under <code>post</code> to configure the all-post copyright setting.</p><pre><code>```yml source/_data/cutie.ymlpost:  allow_share: true  allow_modification: false  allow_commercial: false```</code></pre><p>Default configuration<br>:   If any of these configurations is omitted, the default setting for each one will fall back to following settings,</p><pre><code>* `allow_share: true`, by default allowing sharing all posts.    * `allow_modification: false`, by default post is not allowed to be modified while sharing.    * `allow_commercial: false`, by default post is not allowed to be used for commercial purposes while sharing.The corresponding default Creative Commons license is _CC BY-NC-ND 4.0_.</code></pre><h4 id="For-an-individual-post-3"><a href="#For-an-individual-post-3" class="headerlink" title="For an individual post"></a>For an individual post</h4><p>Configuration file<br>:  A post’s front matter</p><p>Configuration format<br>:   Use the same three variables to configure copyright setting for a specific post.</p><pre><code>```yml---allow_share: trueallow_modification: falseallow_commercial: false---```</code></pre><p>Default configuration<br>:   If any of these variables is omitted in the post front matter, setting will fall back to the <a href="#for-all-posts-v3">all-post copyright setting</a>.</p><h3 id="Enable-post-visit-and-comment-counts"><a href="#Enable-post-visit-and-comment-counts" class="headerlink" title="Enable post visit and comment counts"></a>Enable post visit and comment counts</h3><p>Minimal version<br>:   <code>v2.0.5-beta</code></p><p>Prerequiste<br>:   This functionality only works when you use <code>valine</code> as <a href="#comment-systems">comment system</a> and use <code>leancloud</code> as backend.</p><p>Configuration steps<br>:   1. Configure <code>valine</code> comment system as described <a href="#configuration-for-valine-comment-system">here</a>.</p><pre><code>2. You are all set and post visit counts and post comment counts will appear in all related pages.</code></pre><p>Notes<br>:   * <em>If backend is not set up properly, icons that show post visit and comment counts will be hidden.</em></p><pre><code>* Post visit counts only __unique__ visitors (meaning visitors with unique IPs).</code></pre><h3 id="Enable-post-thumb-up"><a href="#Enable-post-thumb-up" class="headerlink" title="Enable post thumb up"></a>Enable post thumb up</h3><p>Minimal version<br>:   <code>v2.1.0</code></p><p>Prerequiste<br>:   This functionality only works when you use <code>valine</code> as <a href="#comment-systems">comment system</a> and use <code>leancloud</code> as backend.</p><p>Configuration steps<br>:   1. Configure <code>valine</code> comment system as described <a href="#configuration-for-valine-comment-system">here</a>.</p><pre><code>2. You are all set and post thumb up and thumb up counts will appear in all related pages.</code></pre><p>Notes<br>:   * <em>If backend is not set up properly, icons that show post thumbup status and counts will be hidden.</em></p><pre><code>* Post thumb up counts only __unique__ visitors (meaning visitors with unique IPs).</code></pre><h3 id="Use-post-announcement"><a href="#Use-post-announcement" class="headerlink" title="Use post announcement"></a>Use post announcement</h3><p>Minimal version<br>:   <code>v2.0.7</code></p><p>Configuration file<br>:   post’s front matter</p><p>Configuration steps<br>:   Use following snippet to add your post annoucement</p><pre><code>```yml post&#39;s front matter---announcement:  text: This is a sample post announcement!---```</code></pre><p>Notes<br>:   * The default timeout for the announcement is 10 seconds. Note configurable for now.</p><pre><code>* You may use HTML markups in the announcement text.</code></pre><h3 id="Set-post-excerpt"><a href="#Set-post-excerpt" class="headerlink" title="Set post excerpt"></a>Set post excerpt</h3><p>The post excerpt, displayed in the index page card on hover, may be manually set through front matter or adding the <code>&lt;!-- more --&gt;</code> tag plugin in the post.</p><p>Minimal version<br>:   <code>v2.0.11</code></p><p>Configuration file<br>:   post’s front matter, or tag plugin</p><p>Configuration waterfall<br>:   <code>abstract</code> variable in the front matter has the highest priority if set.</p><pre><code>```yml post&#39;s front matter---abstract: A sample excerpt.---```If `abstract` is not set, theme cutie will search `&lt;!-- more --&gt;` tag in the post content to identify the excerpt section and cut off the first 150 characters to be used as excerpt.If both `abstract` and `&lt;!-- more --&gt;` are omitted, theme cutie will automatically chunk the first 150 characters in the post content to be used as excerpt.</code></pre><h3 id="Set-post-icon"><a href="#Set-post-icon" class="headerlink" title="Set post icon"></a>Set post icon</h3><p>The post icon, displayed on the top left cornder of the index page card, may be manually set through front matter in the post.</p><p>Minimal version<br>:   <code>v2.0.0</code></p><p>Configuration file<br>:   post’s front matter</p><p>Configuration waterfall<br>:   If <code>icon</code> variable in the post front matter is set, the system will use this icon for post.</p><pre><code>```yml post&#39;s front matter---icon: /your/post/icon/path---```I recommend you to use absolute path (starting with `/`) for the image path.If `icon` variable is not set, but post belongs to category `notes` or `projects`, the system will use the default category icon for the post.If both conditions are not satisified, the system will use a randomly generated texture image for the post.</code></pre><h2 id="Icon-sets"><a href="#Icon-sets" class="headerlink" title="Icon sets"></a>Icon sets</h2><h3 id="Select-an-icon-set"><a href="#Select-an-icon-set" class="headerlink" title="Select an icon set"></a>Select an icon set</h3><p>Minimal version<br>:   <code>v2.0.5-beta</code></p><p>Configuration file<br>: <code>source/_data/cutie.yml</code></p><p>Configuration format<br>:   Change icon set by changing the name of the icon set in the following snippet. There are three available icon sets in the theme by default: <code>blue-line</code>, <code>blue-shadow</code>, and <code>colorful-outlined</code>.</p><pre><code>```yml source/_data/cutie.ymlglobal:  icon_set: blue-line # Available values in theme: blue-line, blue-shadow, colorful-outlined```</code></pre><p>Default configuration<br>: <code>blue-line</code></p><p>Illustration</p><h3 id="Add-a-new-icon-set"><a href="#Add-a-new-icon-set" class="headerlink" title="Add a new icon set"></a>Add a new icon set</h3><p>Minimal version<br>:   <code>v2.0.5-beta</code></p><p>Configuration path<br>: <code>source/images/</code></p><p>Configuration steps<br>:   1. Create a folder named <code>icons</code> in <code>source/images/</code> folder.</p><pre><code>2. Create an icon set folder `icon-set-name`(change it to your desired name) in `source/images/icons/` folder.3. Add your own four icons (keep the filename consistent) in `svg` format to `source/images/icons/icon-set-name/` folder.    1. `search.svg`    2. `archive.svg`    3. `menu.svg`    4. `toc.svg`4. Use your new icon set name `icon-set-name` in [Select an existing icon set](#select-an-existing-icon-set)</code></pre><h2 id="Comment-systems"><a href="#Comment-systems" class="headerlink" title="Comment systems"></a>Comment systems</h2><h3 id="Select-comment-systems"><a href="#Select-comment-systems" class="headerlink" title="Select comment systems"></a>Select comment systems</h3><p>Minimal version<br>:   <code>v2.0.0-alpha</code></p><p>User configuration location<br>: <code>source/_data/cutie.yml</code></p><p>Configuration format<br>:   ```yml comment system<br>    global:<br>      comment_system: valine # Available values: valine, gitment, disqus</p><pre><code>```</code></pre><p>Possible values<br>:   <code>valine</code>(default), <code>gitment</code>, <code>disqus</code>, <code>livere</code></p><p>After selecting one of the comment systems, you need to further configure it.</p><h3 id="Configuration-for-valine-comment-system"><a href="#Configuration-for-valine-comment-system" class="headerlink" title="Configuration for valine comment system"></a>Configuration for valine comment system</h3><p>Minimal version<br>:   <code>v2.0.0-alpha</code></p><p>User configuration location<br>: <code>source/_data/cutie.yml</code></p><p>Configuration format<br>:   ```yml valine configuration<br>    valine:<br>      appId:<br>      appKey:<br>      placeholder:</p><pre><code>```See https://valine.js.org to setup the backend and fill the values.</code></pre><p>Default values<br>: No default values, must fill if using the system.</p><h3 id="Configuration-for-gitment-comment-system"><a href="#Configuration-for-gitment-comment-system" class="headerlink" title="Configuration for gitment comment system"></a>Configuration for gitment comment system</h3><p>Minimal version<br>:   <code>v2.0.0-alpha</code></p><p>User configuration location<br>: <code>source/_data/cutie.yml</code></p><p>Configuration format<br>:   ```yml gitment configuration<br>    gitment:<br>      owner:<br>      repo:<br>      client_id:<br>      client_secret:</p><pre><code>```See https://github.com/imsun/gitment to setup the backend and fill the values.</code></pre><p>Default values<br>: No default values, must fill if using the system.</p><h3 id="Configuration-for-Disqus-comment-system"><a href="#Configuration-for-Disqus-comment-system" class="headerlink" title="Configuration for Disqus comment system"></a>Configuration for Disqus comment system</h3><p>Minimal version<br>:   <code>v2.0.0-alpha</code></p><p>User configuration location<br>: <code>source/_data/cutie.yml</code></p><p>Configuration format<br>:   ```yml disqus configuration<br>    disqus:<br>      shortname:</p><pre><code>```See https://help.disqus.com/customer/portal/articles/466208-what-s-a-shortname- to setup the backend and fill the value.</code></pre><p>Default values<br>: No default values, must fill if using the system.</p><h3 id="Configuration-for-Livere-comment-system"><a href="#Configuration-for-Livere-comment-system" class="headerlink" title="Configuration for Livere comment system"></a>Configuration for Livere comment system</h3><p>Minimal version<br>:   <code>v2.0.11</code></p><p>User configuration location<br>: <code>source/_data/cutie.yml</code></p><p>Configuration format<br>:   <code>yml livere configuration    livere:      id: &#39;city&#39; # use &#39;city&#39; if using free version or `premium` if using paid version      uid:</code><br>    The <code>uid</code> is the string you will see in the snippet provided by livere during installation, as shown in the following screenshot.</p><pre><code>![Livere setup screenshot](livere_setup.png)</code></pre><p>Default values<br>: No default values, must fill if using the system.</p><h1 id="Math-test"><a href="#Math-test" class="headerlink" title="Math test"></a>Math test</h1><p>$f<em>{i}=\sum\limits</em>{j=1}^n a<em>jb</em>{i-j}$</p><script type="math/tex; mode=display">f_{i}=\sum\limits_{j=1}^n a_jb_{i-j}</script>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
