<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>七彩树 题解</title><meta name="description" content="分块好耶"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="题目传送门
让我们先解决几个问题。
树链问题当树是一条链时，问题变为区间问题。

设结点的下标为其深度，对于每一个点，开一棵线段树维护这样的序列。
在父亲线段树的基础上，在当前结点下标上加一，同时在上一次出现该结点值的地方减一。
查询时在下标为 $dep_x+d$ 的那棵线段树上查询 $[x,n+1)$ 即可。
可以用主席树实现。
（SDOI2009 HH的项链）
我们发现，其实查询 $[l,r+1)$ 就够了。
子树问题每次询问的深度都充分大时，问题变为询问一个子树的问题。
我们扩展上面的做法。观察发现一棵子树在 dfs 序上连续，从而把问题转化为 dfs 序上的区间问题。
原问题这样的询问无法像上面那样转化为区间问题了。
不过可以这么考虑：如果先更新深度小的线段树再更新大的，那岂不是说在一棵树上查询任何.."><meta name="generator" content="Hexo 6.2.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">ppip's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">七彩树 题解</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E9%93%BE%E9%97%AE%E9%A2%98"><span class="toc-text">树链问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E6%A0%91%E9%97%AE%E9%A2%98"><span class="toc-text">子树问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E9%97%AE%E9%A2%98"><span class="toc-text">原问题</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/BZOJ"><i class="tag post-item-tag">BZOJ</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">七彩树 题解</h1><time class="has-text-grey" datetime="2022-07-18T01:49:00.000Z">2022-07-18</time><article class="mt-2 post-content"><p><a href="https://hydro.ac/d/bzoj/p/4771/">题目传送门</a></p>
<p>让我们先解决几个问题。</p>
<h2 id="树链问题"><a href="#树链问题" class="headerlink" title="树链问题"></a>树链问题</h2><p>当树是一条链时，问题变为区间问题。</p>
<span id="more"></span>
<p>设结点的下标为其深度，对于每一个点，开一棵线段树维护这样的序列。</p>
<p>在父亲线段树的基础上，在当前结点下标上加一，同时在上一次出现该结点值的地方减一。</p>
<p>查询时在下标为 $dep_x+d$ 的那棵线段树上查询 $[x,n+1)$ 即可。</p>
<p>可以用主席树实现。</p>
<p>（SDOI2009 HH的项链）</p>
<p>我们发现，其实<strong>查询 $[l,r+1)$ 就够了</strong>。</p>
<h2 id="子树问题"><a href="#子树问题" class="headerlink" title="子树问题"></a>子树问题</h2><p>每次询问的深度都充分大时，问题变为询问一个子树的问题。</p>
<p>我们扩展上面的做法。观察发现一棵子树在 dfs 序上连续，从而把问题转化为 dfs 序上的区间问题。</p>
<h2 id="原问题"><a href="#原问题" class="headerlink" title="原问题"></a>原问题</h2><p>这样的询问无法像上面那样转化为区间问题了。</p>
<p>不过可以这么考虑：如果先更新深度小的线段树再更新大的，那岂不是说在一棵树上<strong>查询任何区间的答案都只统计到当前深度</strong>？</p>
<p>所以我们按 bfs 序去刷新线段树，但是线段树内仍维护 dfs 序，查询时查询<strong>待查集合内 dfs 序最靠后的结点就行了</strong>？</p>
<p>所以思路就是，线段树上维护 dfs 序，但是每个结点从 bfs 序的前一个更新而来，每次颜色相同的、dfs 序上和它距离最小的结点减一。查询的时候在子树内深度 $\leq dep_x+d$ 且在 dfs 序上最靠后的那棵线段树上查询以 $x$ 为根的子树这段 dfs 序即可。</p>
<p>不好意思，错了。</p>
<pre><code>6 1
1 2 3 3 4 5
1 2 1 4 4
4 2
</code></pre><p>这时候是这样一棵树：</p>
<p><img src="https://hydro.ac/d/bzoj/file/2579/graph.png" alt="树的示意图"></p>
<p>每个结点上线段树的值：</p>
<pre><code>// bfs序
1: 100000
2: 110000
4: 110100
3: 111000
5: 111010
6: 111011
</code></pre><p>查询的是结点 $6$ 上的 $[4,6+1)$（按照 dfs 序），答案为 $2$。</p>
<p>事实上，是 $3$ 号结点抹掉了 $4$ 号结点的值。</p>
<p>仔细想想，其实询问同时包含两个结点时，才需要减一。</p>
<p>而同时包含两个结点的，最深是它们的 LCA。所以在 LCA 上减一。</p>
<p>另外，容易发现，查询待查深度的最后一棵线段树即可。此时就算线段树有更改，也一定落在这棵子树的 dfs 序外面。这样每个深度维护一棵线段树即可。</p>
<p>就酱。</p>
<pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
// limits
const int VL&#123;1&#125;,VR(1e5),N(1e5),L&#123;20&#125;;
// persistent seg
struct tnode;
vector&lt;tnode&gt; mem;
struct pnode
&#123;
    int id;
    tnode&amp; operator*()&#123;return mem[id];&#125;
    tnode* operator-&gt;()&#123;return &amp;mem[id];&#125;
    pnode&amp; operator=(pnode n)&#123;id=n.id;return *this;&#125;
    pnode(int p=0):id&#123;p&#125;&#123;&#125;
&#125;;
struct tnode
&#123;
    pnode l,r;
    int sz;
&#125;;
pnode new_tnode()&#123;mem.emplace_back();return mem.size()-1;&#125;
pnode Insert(pnode,int,int,int);
int query(pnode,int,int,int,int);
// tree
vector&lt;int&gt; e[N+5];
int dfp[N+5];
pnode tree[N+5];
// node
int cl[N+5],fa[N+5][L+5];
int dep[N+5],dfn[N+5],sz[N+5],cxx;
int LCA(int,int);
// preparation
pnode init();
// color
set&lt;int&gt; col[N+5];
int close(int);
int main()
&#123;
    int T;cin&gt;&gt;T;
    while (T--)
    &#123;
        int n,m;cin&gt;&gt;n&gt;&gt;m;
        for (int i&#123;1&#125;;i&lt;=n;++i)
            scanf(&quot;%d&quot;,cl+i);
        for (int i&#123;1&#125;;i&lt;=n;++i)
            e[i].clear(),col[cl[i]].clear();
        for (int i&#123;2&#125;;i&lt;=n;++i)
        &#123;
            int p;scanf(&quot;%d&quot;,&amp;p);
            e[p].push_back(i);
            fa[i][0]=p;
        &#125;
        tree[0]=init();
        vector&lt;int&gt; bfn;
        for (int i&#123;1&#125;;i&lt;=n;++i)
            bfn.push_back(i);
        sort(bfn.begin(),bfn.end(),[](int a,int b)&#123;return dep[a]&lt;dep[b]||dep[a]==dep[b]&amp;&amp;dfn[a]&lt;dfn[b];&#125;);
        int ct&#123;0&#125;;
        for (auto u:bfn)
        &#123;
            tree[dep[u]]=Insert(tree[ct],dfn[u],1,n);
            ct=dep[u];
            if (col[cl[u]].size()) tree[ct]=Insert(tree[ct],dfn[close(u)],-1,n);
            col[cl[u]].insert(dfn[u]);
        &#125;
        // cout&lt;&lt;&quot;qwq&quot;&lt;&lt;mem[3].r.id&lt;&lt;endl;
        int last&#123;0&#125;;
        while (m--)
        &#123;
            int x,d;scanf(&quot;%d %d&quot;,&amp;x,&amp;d);
            x^=last;d^=last;
            printf(&quot;%d\n&quot;,last=query(tree[dep[x]+d],dfn[x],sz[x]+1,1,n+1));
        &#125;
    &#125;
    return 0;
&#125;
// binary desp
int jmp(int x,int d)
&#123;
    for (int i&#123;0&#125;;d;++i)
    &#123;
        if (d&amp;1) x=fa[x][i];
        d&gt;&gt;=1;
    &#125;
    return x;
&#125;
int LCA(int a,int b)
&#123;
    if (dep[a]&lt;dep[b]) swap(a,b);
    a=jmp(a,dep[a]-dep[b]);
    if (a==b) return a;
    for (int i&#123;L&#125;;i&gt;=0;--i)
        if (fa[a][i]!=fa[b][i])
            a=fa[a][i],b=fa[b][i];
    return fa[a][0];
&#125;
void fz_init(int u)
&#123;
    dfn[u]=++cxx;dfp[cxx]=u;
    dep[u]=dep[fa[u][0]]+1;
    for (int i&#123;1&#125;;i&lt;=L;++i)
        fa[u][i]=fa[fa[u][i-1]][i-1];
    for (auto v:e[u])
        fz_init(v);
    sz[u]=cxx;
&#125;
pnode init()
&#123;
    cxx=0;
    fz_init(1);
    mem.clear();mem.emplace_back();
    return 0;
&#125;
pnode Insert(pnode p,int k,int v,int cnt)
&#123;
    pnode q&#123;new_tnode()&#125;;
    *q=*p;
    // printf(&quot;%d: p%d,q%d\n&quot;,k,p.id,q.id);
    q-&gt;sz+=v;
    if (cnt==1) return q;
    int cp&#123;cnt&gt;&gt;1&#125;;
    if (k&lt;=cp) q-&gt;l=Insert(p-&gt;l,k,v,cp);
    else q-&gt;r=Insert(p-&gt;r,k-cp,v,cnt-cp);
    // cout&lt;&lt;&amp;(q-&gt;l)&lt;&lt;&quot; &quot;&lt;&lt;&amp;(mem[q.id].l)&lt;&lt;endl;;
    // cout&lt;&lt;q-&gt;l.id&lt;&lt;endl;
    // printf(&quot;fin %d: q%d %d\n&quot;,k,q-&gt;l,q-&gt;r);
    return q;
&#125;
int query(pnode p,int L,int R,int pL,int pR)
&#123;
    if (p.id==0) return 0;
    if (L&lt;=pL&amp;&amp;pR&lt;=R) return p-&gt;sz;
    int mid&#123;pL+pR&gt;&gt;1&#125;,ans&#123;0&#125;;
    if (L&lt;mid) ans+=query(p-&gt;l,L,R,pL,mid);
    if (R&gt;mid) ans+=query(p-&gt;r,L,R,mid,pR);
    return ans;
&#125;
int close(int p)
&#123;
    auto&amp; s&#123;col[cl[p]]&#125;;
    auto il&#123;s.lower_bound(dfn[p])&#125;,iu&#123;s.upper_bound(dfn[p])&#125;;
    if (il!=s.begin())
        if (iu!=s.end())
        &#123;
            int l&#123;LCA(dfp[*prev(il)],p)&#125;,u&#123;LCA(dfp[*iu],p)&#125;;
            if (dep[l]&gt;dep[u]) return l;
            else return u;
        &#125;
        else return LCA(dfp[*prev(il)],p);
    else return LCA(dfp[*iu],p);
&#125;
</code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/p/polyquine/" title="Polyquine —— 同时在多种语言运行的自生成程式"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Polyquine —— 同时在多种语言运行的自生成程式</span></a><a class="button is-default" href="/p/solution-p3591/" title="[POI2015]ODW 题解"><span class="has-text-weight-semibold">Next: [POI2015]ODW 题解</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="NFLSCode/nflscode.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/NFLSCode"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> ppip 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>